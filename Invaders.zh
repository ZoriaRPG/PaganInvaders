// Invaders
// v0.08
// 30th March, 2020
// ZoriaRPG
//
/*
* Change History
* 0.0.1 - Project Begins
* 0.0.2 - Fixed initial compile. 
* 0.0.3 - Added playr::missile, and initial lweapon script. 
* 0.0.4 - Aliens now move, spawn and aniate properly. Player is clamped properly. 
* 	- Player is now animated. Shields are drawn using bitmaps. 
* 	- Known Bugs: Shields are not obliterated by aliens because of logic issues. 
* 0.0.4 - Added player attack. Disabled bunker bitmap/getpixel checks for now. 
* 	- Added sounds and actions. Added player init script. 
* 	- Fixed bugs with enemies not attacking. 
* 0.0.5 - Game now ends on landing. Enemy missiles now damage the player. 
* 0.0.6	- Fixed some visual bugs, and added splat effect. 
* 0.0.7 - Added scoring. Disabled the active subscreen.
* 	- Added additional stages. Show 'R' (round) indicator. 
* 0.0.8 - Some clamping to force step to stay in bounds. 
* 0.1.0 - Refactored aliens.
*/

/*TODO

Make a sngle dummy enemy. It runs the script.
Place all other invaders in an array and move them as a set.

Every frame:

If moving left, find the leftmost invader.
If moving right, find the rightmost invader.
If moving down, find the lowest Y invader.

Store edgenpc and lowestnpc 

CHeck onedge only for the edgemost based on dir
Calculate maximum move left or right based on the current step
	restriced by edge of screen.
Move left or right by the clamped value
If this places them on the edge, flip dir.
Check the pixels for the bunkers one pixel under the lowest invader.
	If they exist, draw a link in a specific colour (0, i suppose) onto each 
	bunker bitmap,. erasing that line.
Check if the lowest invader Y landed.
	If so, GameOver()
Try to fire;
	Up to six shots per second.
		CHoose up to six invaders and randomly shoot. 
	
	THe shot script needs to check its x and Y pos against hardcoded 
	positions for bunkers
	
	If it is inside a bunker. and the spot in the bunker is not colour 0.
		then write colour 0 to its bitmap.
		
	Perhaps it's be better to draw all four bunkers to a single bitmap, so that 
	we can write colour 0 to one bitmap instead of four. 
*/

//Bunnies should drop blue egg bombs

int ofs = 0;
namespace invaders
{
	int alienclk; //one second clock
	int hasturned = 0;
	int gameover = 0;
	const int SPLATSPRITE = 34; 
	namespace shields
	{
		bitmap bnkr[4];
		ffc loc[4] = { NULL, NULL, NULL, NULL };
		const int TILE = 78213;
		const int CSET = 11;
		void init()
		{
			for ( int q = 0; q < 4; ++q )
			{
				loc[q] = NULL;
				bnkr[q] = Game->CreateBitmap(3*16, 2*16);
				printf("bnkr[q]: %d\n", <int>bnkr[q]);
				bnkr[q]->DrawTile(0, 0, 0, TILE, 3, 2, CSET, -1, -1, 0, 0, 0, 0, true, 128);
			}
			
		}
		void draw(ffc f, int spin)
		{
			//printf("bnkr[f->InitD[0]] is: %d\n", <int>bnkr[f->InitD[0]]);
			//bnkr[f->InitD[0]]->Blit(0, RT_SCREEN, 0, 0, 3*16, 2*16, f->X, f->Y, 3*16, 2*16, 0, 0, 0, 0, 0, true);
			//!Revert to this to stop the spin. 
			//bnkr[f->InitD[0]]->Blit(0, <bitmap>(-2), 0, 0, 3*16, 2*16, f->X, f->Y, 3*16, 2*16, 0-(ofs/30), 0, 0, 0, 0, true);
			bnkr[f->InitD[0]]->Blit(0, <bitmap>(-2), 0, 0, 3*16, 2*16, f->X, f->Y, 3*16, 2*16, 0-(ofs/30), 0, 0, 0, 0, true);
			if ( spin ) --ofs;
		}
		ffc script bunker
		{
			void run(int id)
			{
				// Probably doesn't need a script. Changers would work.
				// Oh, but we need to draw it from a bitmap. Flidd. 
				loc[id] = this;
				while(1)
				{
					draw(this, (this->InitD[1]));
					Waitframe();
				}
			}
		}
		
	}
	
	void runclock()
	{
		++alienclk;
		if ( alienclk > 59 ) alienclk = 0;
	}
	void nextstage()
	{
		//Audio->PlaySound(5);
		++Game->Counter[CR_KEYS];
		aliens::theinvaders.spawn(aliens::theinvaders.swarm);
	}
	global script inv
	{
		void run()
		{
			playr::init();
			shields::init(); //Set up bunker bitmaps.
			aliens::init(); //Set up temp bitmap for shield collisions. 
			//aliens::spawn();
			while(1)
			{
				if ( gameover ) 
				{
					GameOver();
				}
				//runclock();
				//aliens::animate();
				playr::animate();
				playr::clamp();
				playr::attack();
				
				/*if ( aliens::hitedge )
				{
					printf("hit screen edge\n");
					for ( int qe = Screen->NumNPCs(); qe > 0; --qe )
					{
						npc nn = Screen->LoadNPC(qe);
						
						switch(nn->Dir)
						{
							case DIR_LEFT:
							{
								//++nn->X;
								nn->Dir = DIR_RIGHT;
								aliens::descend(nn);
								break;
							}
							case DIR_RIGHT:
							{
								//--nn->X;
								nn->Dir = DIR_LEFT;
								aliens::descend(nn);
								break;
							}
						}
					}
					aliens::hitedge = 0;
				}
				*/
				unless(Screen->NumNPCs() > 1)
				{
					nextstage();
				}
				Waitdraw();
				playr::clamp();
				Waitframe();
			}
		}
	}
	
	global script newgame
	{
		void run()
		{
			playr::init();
			shields::init(); //Set up bunker bitmaps.
			aliens::init(); //Set up temp bitmap for shield collisions. 
			//aliens::animate();
			//aliens::spawn();
		}
	}
	
	void GameOver()
	{
		while(1)
		{
			Screen->DrawString(7, 100, 100, 1, 0x92, 0x0F, 0, "    GAME OVER    ", 128);
			Waitframe();
		}
	}
		
	namespace aliens
	{
		npc grid[theinvaders.NUMINVADERS]; 
		int turn_cooldown = 0; 
		int hitedge = 0;
		const int COOLDOWN_TIME = 15;
		enum adir { dLeft, dRight, dLast };
		const int DESCEND_Y_PIXELS = 16;
		const int FIRECLK = 1;
		const int FIRECLK_MIN = 100;
		const int FIRECLK_MAX = 400;
		const int FIRST = 180;
		
		bitmap tmpbmp;
		void init()
		{
			tmpbmp = Game->CreateBitmap(16,16);
		}
		
		const int STARTX = 32;
		const int STARTY = 16;
		
		enum starttile { stA = 78000, stB = 78020, stC = 78040, stD = 78000 }; //unintentional Pun. 
		
		const int INITIALSTEP = 8; //pixels per second!, not frame
		int step = INITIALSTEP; //This increases as enemies die.
		
		void wipegrid()
		{
			for ( int q = 0; q < theinvaders.NUMINVADERS; ++q ) 
			{
				grid[q] = NULL;
				theinvaders.swarm[theinvaders.NUMINVADERS] = NULL;
			}
			theinvaders.lowest = NULL;
			theinvaders.leftmost = NULL;
			theinvaders.rightmost = NULL;
			theinvaders.curstep = INITIALSTEP;
			
		}
		
		//Misc[]
		const int aclk = 2; 
		const int curtile = 3;
		
		
		
		const int MAXEW = 6;
		const int ATKSFX = 1;
		
		
		const int MISSILESPR = 10;
		const int STEP = 2;
		eweapon script enemy_missile
		{
			void run()
			{
				this->Dir = DIR_DOWN;
				int type2 = Rand(1);
				this->UseSprite(MISSILESPR + (type2));
				this->Damage = 2;
				int step = STEP + type2;
				while(1)
				{
					//for every pixel of movement, check collisions.
					for ( int q = 0; q < STEP; ++q )
					{
						++this->Y;
						//if there is a collision, move until reaching that Y pos, then kill the missile.
						
						//otherwise complete full move. 
					}
					
					Waitdraw();
					Waitframe();
				}
			}
		}
		
		
		const int STEPSFX = 3;
		int maxstep;
		
		npc script theinvaders
		{
			const int NUMINVADERS = 48;
			npc lowest = NULL;
			npc leftmost = NULL;
			npc rightmost = NULL;
			npc swarm[NUMINVADERS];
			int curstep = INITIALSTEP;
			void run()
			{
				
				npc leader = this; 
				this->Dir = DIR_RIGHT;
				this->HitYOffset = -32678; //Can't be hit
				this->DrawYOffset = -32678; //Can't be seen
				
				int lx, ly;
				int invclk = 0;
				spawn(swarm);
				while(1)
				{
					for ( int q = 0; q < NUMINVADERS; ++q )
					{
						//If moving right, find the rightmost invader.
						if ( this->Dir == DIR_RIGHT )
						{
							if ( swarm[q]->isValid() )
							{
								if ( swarm[q]->X > (( rightmost->isValid() ) ? rightmost->X : -1) )
								{
									rightmost = swarm[q];
								}
							}
						}
						//If moving left, find the leftmost invader.
						else
						{
							if ( swarm[q]->isValid() )
							{
								if ( swarm[q]->X < (( leftmost->isValid() ) ? leftmost->X : 300) )
								{
									leftmost = swarm[q];
								}
							}
						}
						
						
						//If moving down, find the lowest Y invader.
						if ( swarm[q]->isValid() )
						{
							if ( swarm[q]->Y > (( lowest->isValid() ) ? lowest->Y : 0) )
							{
								lowest = swarm[q];
							}
						}
					}
					
					splat(swarm);
					move(leader, swarm, invclk);
					animate(swarm);
					attack(swarm);
					cleanup(swarm);
					
					//Check for Landing
					if ( lowest->Y >= 152 )
					{
						gameover = 1;
					}
					
					++invclk;
					Waitframe();
				}
			}
			void spawn(npc swarm)
			{
				wipegrid(); //Clear old pointers. 
				int id = FIRST; int x = STARTX, y = STARTY;
				starttile tiles[4] = { stA, stB, stC, stD };
				for ( int q = 0; q < NUMINVADERS; ++q )
				{
					if ( (q) && (!(q%12)) ) //start of a row
					{
						++id;
						y += 16;
						x = STARTX;
					}
					swarm[q]->ScriptTile = swarm[q]->OriginalTile;
					swarm[q] = Screen->CreateNPC(id);
					swarm[q]->X = x; swarm[q]->Y = y; //Position on the grid.
					swarm[q]->DrawYOffset = -8;
					swarm[q]->HitYOffset = -8; //So that they 'land' at the visible 8th pixel.
					x += 16; //Increment column.
					grid[q] = swarm[q]; //Stor its pointer into the grid. 
				}
				
				
			}
			
			void animate(npc swarm)
			{
				for ( int q = 0; q < NUMINVADERS; ++q )
				{
					if ( swarm[q]->isValid() )
					{
						++swarm[q]->Misc[aclk]; 
						unless (( swarm[q]->Misc[aclk]%16 ))
						{
							if ( swarm[q]->Misc[curtile] < 7 )
							{
								++swarm[q]->ScriptTile;
								++swarm[q]->Misc[curtile];
							}
							else
							{
								swarm[q]->ScriptTile = swarm[q]->OriginalTile;
								swarm[q]->Misc[curtile] = 0;
							}
						}
					}
					
				}
				
			}
			
			const int SPLATTED = 6;
			void splat(npc swarm)
			{
				for ( int q = 0; q < NUMINVADERS; ++q )
				{
					if ( swarm[q]->isValid() && swarm[q]->HP < 1 )
					{
						unless(swarm[q]->Misc[SPLATTED])
						{
							lweapon splat = Screen->CreateLWeapon(LW_SPARKLE);
							splat->HitYOffset = -32768; 
							splat->HitYOffset = -37768;
							splat->UseSprite(SPLATSPRITE);
							
							splat->X = swarm[q]->X;
							splat->Y = swarm[q]->Y;
							Game->Counter[CR_RUPEES] += swarm[q]->Y;
							swarm[q]->Misc[SPLATTED] = 1;
						}
					}
				}
			}
			
			void move(npc leader, npc swarm, int clk)
			{
				unless ( clk%60 )
				{
					Audio->PlaySound(STEPSFX);
					switch(leader->Dir)
					{
						case DIR_LEFT:
						{
							//if on a screen edge
							if ( leftmost->X <= 1 ) 
							{
								descend(swarm);
								leader->Dir = DIR_RIGHT;
							}
							else
							{
								//Find the maximum step
								int maxstep = ( leftmost->X - curstep > -1 ) ? maxstep : leftmost->X;
								//Move the full step up to the edge of the screen, but not beyond
								for ( int q = 0; q < NUMINVADERS; ++q )
								{
									swarm[q]->X -= maxstep;
								}
							}
							break;
						}
						case DIR_RIGHT:
						{
							//if on a screen edge
							if ( leftmost->X >= 239 ) 
							{
								descend(swarm);
								leader->Dir = DIR_LEFT;
							}
							else
							{
								//Find the maximum step
								int maxstep = ( rightmost->X + curstep < 241 ) ? maxstep : (240-rightmost->X);
								//Move the full step up to the edge of the screen, but not beyond
								for ( int q = 0; q < NUMINVADERS; ++q )
								{
									swarm[q]->X += maxstep;
								}
							}
							break;
						}
						
					}
					
				}
			}
			
			void descend(npc swarm)
			{
				for ( int q = 0; q < NUMINVADERS; ++q )
				{
					if ( swarm[q]->isValid() )
					{
						swarm[q]->Y += DESCEND_Y_PIXELS;
					}
				}
			}
			const int FIRING = 7; //Misc index to mark that an npc is firing. 
			void attack(npc swarm)
			{
				//count remaining aliens
				
				int count = 0; int truecount = 0;
				npc canfire[NUMINVADERS]; int cf_ix = 0;
				for ( int q = 0; q < NUMINVADERS; ++q )
				{
					if ( swarm[q] ->isValid() && swarm[q]->HP > 0 )
					{
						++count;
						//++truecount;
						canfire[cf_ix] = swarm[q];
						++cf_ix; //Put all aliens that can fire into a sequential list.
					}
				}
				unless(count) { return; } //no aliens left
				//choose up to six aliens to fire shots
				count = Clamp(count, 1, 6); //vound the max shots
				count = Rand(count)+1; //choose a random number of shots, min 1
				
				//Get length of truecount array
				for ( int truecount = 0; canfire[truecount]->isValid(); ++truecount );
				
				//Select 'count' random invaders to fire. 
				do{
					int firepos = Rand(0, truecount);
					unless ( canfire[firepos]->Misc[FIRING] ) //unless it is firing this time
					{
						canfire[firepos]->Attack();
						canfire[firepos]->Misc[FIRING] = 1;
						--count;
					}
						
				} while (count); //Until count is 0.
				
				/* would be nice if we allowed variable arrays locally
				npc positions[truecount];
				if ( swarm[q] ->isValid() && swarm[q]->HP > 0 )
				{
					++count;
					++truecount;
				}
				*/
			}
			void cleanup(npc swarm)
			{
				//cleanup of status values
				for ( int q = 0; q < NUMINVADERS; ++q )
				{
					if ( swarm[q]->isValid() )
					{
						//clear attacking status
						swarm[q]->Misc[FIRING] = 0;
					}
				}
			}
		} // end run 
	} // end script

	namespace playr
	{
		//int cooldown = 0;
		// Player movement and firing.
		namespace missile
		{
			int clk, step, cool, x, y;
			const int SPRITE = 63;
			const int STEP = 2; //pixels per frame
			const int TYPE = LW_ARROW;
			const int XOFS = 0; 
			const int YOFS = -16;
			//missile bounding box. 
			const int HEIGHT = 12;
			const int WIDTH = 4;
			const int HITXOFS = 6;
			const int HITYOFS = 2;
			
			lweapon script player_missile
			{
				void run()
				{
					while(1)
					{
						//for every pixel of movement, check collisions.
						for ( int q = 0; q < STEP; ++q )
						{
							--this->Y;
							//if there is a collision, move until reaching that Y pos, then kill the missile.
							for ( int q = Screen->NumNPCs(); q < 0; --q )
							{
								npc n = Screen->LoadNPC(q);
								if ( Collision(this,n) ) break;
							}
							//otherwise complete full move. 
						}
						
						Waitdraw();
						Waitframe();
					}
				}
			}
			
		}
		void clamp()
		{
			//enum bounds { UPPER, LOWER, LEFT, RIGHT, LAST };
			Player->X = Clamp(Player->X, 0, 238);
			Player->Y = 152;
			Player->Dir = DIR_UP;
		}
		const int MISSILESPR = 11;
		const int ATKSFX = 2;
		void attack()
		{
			if ( Link->PressA ) 
			{
				if ( Screen->NumLWeapons() ) 
				{
					return;
				}
				lweapon m = Screen->CreateLWeapon(missile::TYPE);
				m->Dir = DIR_UP;
				m->X = Player->X + missile::XOFS;
				m->Y = Player->Y + missile::YOFS;
				m->Step = 0; //Moves by weapon script. 
				m->Script = Game->GetLWeaponScript("player_missile");
				m->UseSprite(MISSILESPR);
				m->Power = 1;
				Audio->PlaySound(ATKSFX);
			}
		}
		const int FIRST = 78060;
		const int aclk = 2;
		const int curtile = 3;

		void init()
		{
			Game->Counter[CR_KEYS] = 1;
			Game->DisableActiveSubscreen = true;
			Player->ScriptTile = 78060;
		}
		
		player script initial
		{
			void run()
			{
				init();
			}
		}
		
		void animate()
		{
			++Player->Misc[aclk]; 
				unless (( Player->Misc[aclk]%16 ))
				{
					if ( Player->Misc[curtile] < 7 )
					{
						++Player->ScriptTile;
						++Player->Misc[curtile];
					}
					else
					{
						Player->ScriptTile = FIRST;
						Player->Misc[curtile] = 0;
					}
				}
				
		}
					
		
		
	}
	namespace shields
	{
		
		
	}
}