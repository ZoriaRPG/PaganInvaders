#include "std.zh"
// Invaders
// v0.6.0
// 20th April, 2020
// ZoriaRPG
//
/*
* Change History
* 0.0.1 - Project Begins
* 0.0.2 - Fixed initial compile. 
* 0.0.3 - Added playr::missile, and initial lweapon script. 
* 0.0.4 - Aliens now move, spawn and aniate properly. Player is clamped properly. 
* 	- Player is now animated. Shields are drawn using bitmaps. 
* 	- Known Bugs: Shields are not obliterated by aliens because of logic issues. 
* 0.0.4 - Added player attack. Disabled bunker bitmap/getpixel checks for now. 
* 	- Added sounds and actions. Added player init script. 
* 	- Fixed bugs with enemies not attacking. 
* 0.0.5 - Game now ends on landing. Enemy missiles now damage the player. 
* 0.0.6	- Fixed some visual bugs, and added splat effect. 
* 0.0.7 - Added scoring. Disabled the active subscreen.
* 	- Added additional stages. Show 'R' (round) indicator. 
* 0.0.8 - Some clamping to force step to stay in bounds. 
* 0.1.0 - Refactored aliens.
* 0.1.1 - Refactored attacking and splatting.
* 0.1.2 - Backported to Alpha 51 due to Rob's parser improvements bricking
* 	  npc pointers in a for loop. 
* 	  Worked on new movemnt system for enemies. 
* 0.1.3 - Start adding bunker destruction.
* 0.1.4 - Restore 'nextstage'. Disable tracing unless DEBUG is on. 
*	- Disable bunker collision unless SKIPBUNKERS is off. 
* 	- Added UFO. 
* 0.1.5 - Increased playr shot speed by +50% and increased minimum enemy attack clk slightly. 
* 	- Game Over now suspends the game.
* 0.1.6 - Invaders now descent 8px, not 16px.
* 0.1.7 - Fixed UFO collision and points. Adjusted the way that invader step is calculated. 
* 	- Slowed UFO speed a bit. Added 20 frames of grace in invader descent phase. 
* 	- Fixed a bug where X/Y on the swarm pointer were accessed during nextstage() prior to being respawned. 
* 0.2.0 - Implemented bunkers, after fixing Getpixel in th ZC interpreter.
*	- Now requires Alha 58.
* 0.2.1 - Fixed UFO double spawn. Added UFO score display. Fixed other bugs with UFO. 
* 0.3.0 - Begin adding the ability for player weapons to damage bunkers.
* 0.3.1 - Corrected formulae for player shots damaging bunkers. 
* 0.3.2 - Corrected formulae for invader shots damaging bunkers.
* 0.3.3 - Slight adjustments to player and enemy shots and bunker destruction.
* 	- Tuned them, and added constants. I'm satisfied with them, now. 
* 0.4.0 - Add life regen based on points. Added proper high score tracking. Reset P1 score on death/continue game.
* 0.4.1 - Added sound effects for destroying the UFO, for Game Over, and for Life Refill.
* 	- Death now calls GameOver(), and GameOver() now terminates all other sfx.
* 	- You now get a YOU WIN screen and sound if you reach R256.
* 0.5.0 - Added opening crawl and intro tune.
* 0.5.1 - Cleanup of comments and logging.
* 0.5.2 - Remove call to bitmap->Write and add Waitframe prior to blit call.
* 0.5.3 - End extra sounds during GameOver and WinGame.
* 0.6.0 - Added difficulty settings and menu. Regenerate shields based on difficulty level.
* 	- Erase bunkers as invaders touch them. Next stage reduces aliens step clock based on difficulty. 
* 	- Tightened hitbox around player weapons; and modified their speed, which is further affected by difficulty. 
* 	- UFO is slightly slower on NORMAL difficulty. Adjusted the area of UFO extra life, based on difficulty. 
* 0.6.1 - Fixed extra 's' in MasSochist. 
*/

/*TODO

2P vs and 2P cooperative modes.

Galaxian attack waves.

Moving bunkers--an arcade DIP/ROM difficulty option.

Invader step clk and bgm speed based on numinvaders, not inc when killed.

Bunnies could drop blue egg bombs, as their weapons.

*/

#include "bitmap.zh"
int ofs = 0;
namespace invaders
{
	int alienclk; //one second clock
	int hasturned = 0;
	int gameover = 0;
	int difficulty = 1;
	const int SPLATSPRITE = 34; 
	const bool SKIPBUNKERS = 0;
	const bool DEBUG = 0;
	
	const int CR_HISCORE = CR_SCRIPT1;
	const int CR_SCORE_P1 = CR_RUPEES;
	const int CR_ROUND = CR_KEYS;
	const int SFX_GAMEOVER = 9;
	const int SFX_WIN = 12;
	const int SFX_INTRO = 13;
	
	namespace shields
	{
		bitmap bnkr[4];
		ffc loc[4] = { NULL, NULL, NULL, NULL };
		const int TILE = 78213;
		const int CSET = 11;
		void init()
		{
			for ( int q = 0; q < 4; ++q )
			{
				loc[q] = NULL;
				bnkr[q] = Game->CreateBitmap(3*16, 2*16);
				bnkr[q]->DrawTile(0, 0, 0, TILE, 3, 2, CSET, -1, -1, 0, 0, 0, 0, true, 128);
				
			}
		}
		void regenerate()
		{
			for ( int q = 0; q < 4; ++q )
			{
				bnkr[q]->DrawTile(0, 0, 0, TILE, 3, 2, CSET, -1, -1, 0, 0, 0, 0, true, 128);
			}
		}
		const int HEIGHT = 32;
		const int WIDTH = 48;
		
		namespace one
		{
			const int minX = 16;
			const int maxX = 16+(16*2)-1;
			const int minY = 118;
		}
		namespace two
		{
			const int minX = 79;
			const int maxX = 79+(16*2)-1;
			const int minY = 118;
		}
		namespace three
		{
			const int minX = 143;
			const int maxX = 143+(16*2)-1;
			const int minY = 118;
		}
		namespace four
		{
			const int minX = 205;
			const int maxX = 205+(16*2)-1;
			const int minY = 118;
		}
		
		int getpositionX(int id)
		{
			return loc[id]->X;
		}
		int getpositionY(int id)
		{
			return loc[id]->Y;
		}
		
		void draw(ffc f, int spin)
		{
			bnkr[f->InitD[0]]->Blit(2, <bitmap>(-2), 0, 0, 3*16, 2*16, f->X, f->Y, 3*16, 2*16, 0-(ofs/30), 0, 0, 0, 0, true);
			if ( spin ) --ofs;
		}
		ffc script bunker
		{
			void run(int id)
			{
				// Probably doesn't need a script. Changers would work.
				// Oh, but we need to draw it from a bitmap. Flidd. 
				loc[id] = this;
				Waitframe();
				while(1)
				{
					draw(this, (this->InitD[1]));
					Waitframe();
				}
			}
		}
		
	}
	
	void runclock()
	{
		++alienclk;
		if ( alienclk > 59 ) alienclk = 0;
	}
	void nextstage()
	{
		aliens::theinvaders.stepclk = 20 - difficulty;
		aliens::theinvaders.invclk = 0 + (((difficulty-1)*0.5)<<0);
		Audio->PlaySound(4);
		++Game->Counter[CR_ROUND];
		int result = ( ((Game->Counter[CR_ROUND])%difficulty) );
		printf("shield modulus result: %d\n", result);
		unless ( ((Game->Counter[CR_ROUND])%difficulty) ) shields::regenerate();
		if ( Game->Counter[CR_ROUND] > 255 ) WinGame();
		aliens::theinvaders.spawn(aliens::theinvaders.swarm);
	}
	
	global script inv
	{
		enum { lfPrevious, lfCurrent, lfLAST }; 
		void update_hiscore()
		{
			if (Game->Counter[CR_SCORE_P1] > Game->Counter[CR_HISCORE] )
			{				
				Game->Counter[CR_HISCORE] = Game->Counter[CR_SCORE_P1];
			}
		}
		void run()
		{
			int lastlifefill[lfLAST] = {0}; 
			playr::init();
			shields::init(); //Set up bunker bitmaps.
			aliens::init(); //Set up temp bitmap for shield collisions and UFO clock. 
			
			Waitframes(100);
			
			while(1)
			{
				if ( gameover ) 
				{
					GameOver();
				}
				
				playr::animate();
				playr::clamp();
				playr::attack();
				playr::lifefill(lastlifefill);
				
				update_hiscore();
				
				Waitdraw();
				playr::clamp();
				Waitframe();
			}
		}
	}
	
	
	player script playeractive
	{
		void run()
		{
			while(1)
			{
				if ( Player->HP < 1 )
				{
					Player->HP = 1;
					GameOver();
				}
				Waitframe();
			}
		}
	}
	//! Would be nice, but you can't press F6 during this script.
	//player script death
	//{
	//	void run()
	//	{
	//		//Game->Save(); //Saving delays display of the text and the audio effect for 30 seconds on my SSD. Let this be a menu.
	//		GameOver();
	//	}
	//}
	
	global script newgame
	{
		void run()
		{
			playr::init();
			shields::init(); //Set up bunker bitmaps.
			aliens::init(); //Set up temp bitmap for shield collisions. 
			printf("Game Difficulty: %d\n", difficulty);
		}
	}
	
	void GameOver()
	{
		Game->Suspend[susptGUYS] = true;
		Game->Suspend[susptLWEAPONS] = true;
		Game->Suspend[susptEWEAPONS] = true;
		Game->Suspend[susptLINK] = true;
		Game->Suspend[susptLWEAPONSCRIPTS] = true;
		Game->Suspend[susptEWEAPONSCRIPTS] = true;
		Game->Suspend[susptNPCSCRIPTS] = true;
		for ( int q = 0; q < 20; ++q ) 
		{
			Audio->EndSound(q);
		}
		Audio->PlaySound(SFX_GAMEOVER);
		while(1)
		{
			Screen->DrawString(7, 100, 100, 1, 0x92, 0x0F, 0, "    GAME OVER    ", 128);
			Waitframe();
		}
		
	}
	
	void WinGame()
	{
		Game->Suspend[susptGUYS] = true;
		Game->Suspend[susptLWEAPONS] = true;
		Game->Suspend[susptEWEAPONS] = true;
		Game->Suspend[susptLINK] = true;
		Game->Suspend[susptLWEAPONSCRIPTS] = true;
		Game->Suspend[susptEWEAPONSCRIPTS] = true;
		Game->Suspend[susptNPCSCRIPTS] = true;
		for ( int q = 0; q < 20; ++q ) 
		{
			Audio->EndSound(q);
		}
		Audio->PlaySound(SFX_WIN);
		while(1)
		{
			Screen->DrawString(7, 100, 100, 1, 0x92, 0x0F, 0, "     YOU WIN     ", 128);
			Waitframe();
		}
		
	}
		
	namespace aliens
	{
		npc grid[theinvaders.NUMINVADERS]; 
		int turn_cooldown = 0; 
		int hitedge = 0;
		const int COOLDOWN_TIME = 15;
		enum adir { dLeft, dRight, dLast };
		const int DESCEND_Y_PIXELS = 4;
		const int FIRECLK = 1;
		const int FIRECLK_MIN = 100;
		const int FIRECLK_MAX = 400;
		const int FIRST = 180;
		
		const int UFO = 39;
		int ufoclk = 0;
		
		bitmap tmpbmp;
		
		void init()
		{
			tmpbmp = Game->CreateBitmap(16,16);
			ufoclk = Rand((60), (4*60));
		}
		
		const int STARTX = 32;
		const int STARTY = 16;
		
		enum starttile { stA = 78000, stB = 78020, stC = 78040, stD = 78000 }; //unintentional Pun. 
		
		const int INITIALSTEP = 1; //pixels per second!, not frame
		int step = INITIALSTEP; //This increases as enemies die.
		
		void wipegrid()
		{
			for ( int q = 0; q < theinvaders.NUMINVADERS; ++q ) 
			{
				grid[q] = NULL;
				theinvaders.swarm[q] = NULL;
			}
			theinvaders.lowest = NULL;
			theinvaders.leftmost = NULL;
			theinvaders.rightmost = NULL;
			theinvaders.curstep = INITIALSTEP;
			
		}
		
		//Misc[]
		const int aclk = 2; 
		const int curtile = 3;
		
		const int MAXEW = 6;
		const int ATKSFX = 1;
		
		
		const int MISSILESPR = 10;
		const int STEP = 2;
		const int STEPSFX = 3;
		
		int maxstep;
		
		int CSET(int c)
		{
			return c*0xF;
		}
		int COLOR(int c, int inx)
		{
			return c+inx;
		}
		
		void BreakWaitframe()
		{
		    Waitframe();
		    Debug->Breakpoint(NULL);
		}

		const int SPLATTED = 6;
		int AttClk_Min = 400; //not const
		int AttClk_Max = 1000; //not const
		const int TILE_BLANK = 5;
		const int SFX_UFO_DEAD = 5;
		
		const int SFX_LIFEFILL = 7;
		const int SFX_UFO_GBSFX = 8;
		const int SCORE_FRAMES = 45;
		const int SCORE_X = 4;
		const int SCORE_Y = 4;
		const int ISUFO = 5; //Misc[]
		const int NOREWARD = 6; //Misc[]
		npc script ufo
		{
			void run()
			{
				int clk;
				this->Misc[ISUFO] = 1;
				int points = this->InitD[Rand(4)];
				this->DrawYOffset = -18;
				this->HitHeight = 32;
				this->HitYOffset = 0;
				this->Y += 8;
				this->ScriptTile = this->OriginalTile;
				int stpclk = (4 - difficulty); 
				int ufostep;
				switch(difficulty)
				{
					case 1: ufostep = 1; break;
					case 2: 
					case 3:
						ufostep = 2; break;
				}
				while(this->HP > 0)
				{
					unless((clk%stpclk))
					{
						this->X -= ufostep; //Move left.
					}
					++ufoclk; //Don't let it fall below 0 so that more than one canna spawn.
					if ( this->X < -20 )
					{
						this->Misc[NOREWARD] = 1; 
						this->HP = HP_SILENT;
						ufoclk = Rand((100), (4*60));
					}
					++this->Misc[aclk]; 
					unless (( this->Misc[aclk]%16 ))
					{
						if ( this->Misc[curtile] < 7 )
						{
							++this->ScriptTile;
							++this->Misc[curtile];
						}
						else
						{
							this->ScriptTile = this->OriginalTile;
							this->Misc[curtile] = 0;
						}
					}
					Waitframe();
				}
				if ( this->X > (200 + (difficulty*10)) ) //if the player shot it as it first appears
				{
					Audio->PlaySound(SFX_LIFEFILL);
					Game->DCounter[CR_LIFE] += playr::HP_PER_LIFE_FILL;
				}
				Audio->EndSound(SFX_UFO_GBSFX);
				
				this->ScriptTile = TILE_BLANK; 
				
				unless ( this->Misc[SPLATTED] || this->Misc[NOREWARD] ) //player killed it
				{
					Game->Counter[CR_SCORE_P1] += points;
					Audio->PlaySound(SFX_UFO_DEAD);
				}
				
				this->Misc[SPLATTED] = 1;
				ufoclk = Rand((100), (4*60))+ SCORE_FRAMES;
				for ( int q = 0; q < 4; ++q )
				{
					lweapon splat = Screen->CreateLWeapon(LW_SPARKLE);
					splat->CollDetection = false;
					splat->HitYOffset = -32768; 

					splat->UseSprite(SPLATSPRITE);
					splat->X = this->X;
					splat->DrawXOffset = this->DrawXOffset + Rand(-2,2);
					splat->Y = this->Y;
					splat->DrawYOffset = this->DrawYOffset + Rand(-2,2);
				}
				
				for ( int q = 0; q < SCORE_FRAMES; ++q )
				{
					Screen->DrawInteger(7, this->X+SCORE_X, this->Y+this->DrawYOffset+SCORE_Y, 
						FONT_AQUARIUS, COLOR(CSET(6),8), -1, -1, -1, points, 0, 128);
					Waitframe();
					
				}
			}
		}
		
		ffc script killall
		{
		    void run()
		    {
			Waitframes(10);
			for(int q = Screen->NumNPCs(); q > 0; ++q)
			{
			    npc n = Screen->LoadNPC(q);
			    n->HP = 0;
			}
		    }
		}
		
		eweapon script enemy_missile
		{
			void run()
			{
				this->Dir = DIR_DOWN;
				int type2 = Rand(1);
				this->UseSprite(MISSILESPR + (type2));
				
				this->Damage = 2;
				bitmap playfield;
				unless(SKIPBUNKERS)
				{
					playfield = Game->LoadBitmapID(RT_SCREEN);
				}
				int step = STEP + type2;
				Waitdraw();
				
				
				while(1)
				{
					//for every pixel of movement, check collisions.
					for ( int q = 0; q < STEP; ++q )
					{
						++this->Y;
						
						//if there is a collision, move until reaching that Y pos, then kill the missile.
						/*if ( this->Y > 110 )*/
						const int DESTROY_Y_OFFSET = -2;
						const int ENEMY_ERODE_RADIUS = 4;
						unless(SKIPBUNKERS)
						{
							bitmap scrn = Game->LoadBitmapID(RT_SCREEN);
							int col2 = scrn->GetPixel(this->X+8, this->Y+17) * 10000; //penetrates one pixel
							
							if ( col2 >= (177) && col2 < (192) ) //cset 11
							{
								bool skip;
								if ( this->X+4 < shields::four::minX )
								{
									//must be shield 1, 2, or 3
									if ( this->X+4 < shields::three::minX )
									{
										//must be shield 1, 2
										if ( this->X+4 < shields::two::minX )
										{
											//must be shield 1
											
											int hitpos = (this->X+8) - shields::one::minX;
											int impact = (this->Y+17) - shields::one::minY; //Abs(118-(this->Y))+DESTROY_Y_OFFSET; //the depth of the impact
											
											invaders::shields::bnkr[0]->Circle(1, hitpos, impact, ENEMY_ERODE_RADIUS, 0, 1, 0,0,0, true, 128);
											this->DeadState = WDS_DEAD;
											
											Quit();
												
											
											
										}
										else
										{
											//must be shield 2
											int hitpos = (this->X+8) - shields::two::minX;
											int impact = (this->Y+17) - shields::two::minY; //the depth of the impact
											
											invaders::shields::bnkr[1]->Circle(1, hitpos, impact, ENEMY_ERODE_RADIUS, 0, 1, 0,0,0, true, 128);
											this->DeadState = WDS_DEAD;
											
											Quit();
												
											
										}
										
									}
									else
									{
										//must be shield 3
										int hitpos = (this->X+8) - shields::three::minX;
										int impact = (this->Y+17) - shields::three::minY; //the depth of the impact
										
										invaders::shields::bnkr[2]->Circle(1, hitpos, impact, ENEMY_ERODE_RADIUS, 0, 1, 0,0,0, true, 128);
										this->DeadState = WDS_DEAD;
											
										Quit();
											
										
									}
									
								}
								else
								{
									//must be shield 4
									int hitpos = (this->X+8) - shields::four::minX;
									int impact = (this->Y+17) - shields::four::minY; //the depth of the impact
									
									invaders::shields::bnkr[3]->Circle(1, hitpos, impact, ENEMY_ERODE_RADIUS, 0, 1, 0,0,0, true, 128);
									this->DeadState = WDS_DEAD;
											
									Quit();
										
									
								}
							}
						}
						//otherwise complete full move. 
					}
					
					Waitdraw();
					Waitframe();
				}
			}
		}
		
		npc script splatted
		{
			const int SCORE = 0;
			void run()
			{
				int attackclk = Rand(AttClk_Min,AttClk_Max);
				if ( this->Misc[ISUFO] ) Quit();
				while(1)
				{
					if ( this->isValid() )
					{
						if ( this->HP < 1 )
						{
							unless ( this->Misc[SPLATTED] )
							{
								for ( int q = 0; q < 4; ++q )
								{
									lweapon splat = Screen->CreateLWeapon(LW_SPARKLE);
									splat->HitYOffset = -32768; 
									splat->HitYOffset = -37768;
									splat->UseSprite(SPLATSPRITE);
									
									splat->X = this->X+this->DrawXOffset + Rand(-2,2);
									splat->Y = this->Y+this->DrawYOffset + Rand(-2,2);
									theinvaders.stepclk -= 0.25;
								}
								
								Game->Counter[CR_SCORE_P1] += this->InitD[SCORE];
								this->Misc[SPLATTED] = 1;
							}
							
						}
						else
						{
							unless(attackclk)
							{
								{
									this->Attack();
									attackclk = Rand(AttClk_Min,AttClk_Max);
									//if (DEBUG) printf("attackclk is: %d\n", attackclk);
								}
							}
							else --attackclk;
						}
					}
					Waitdraw();
					Waitframe();
				}
			}
		}
		
		npc script theinvaders
		{
			const int NUMINVADERS = 48;
			npc lowest = NULL;
			npc leftmost = NULL;
			npc rightmost = NULL;
			npc swarm[NUMINVADERS];
			int curstep = INITIALSTEP;
			int invclk = 0;
			void run()
			{
				
				npc leader = this; 
				this->Dir = DIR_RIGHT;
				this->HitYOffset = -32678; //Can't be hit
				this->DrawYOffset = -32678; //Can't be seen
				
				int lx, ly;
				
				
				spawn(swarm);
				
				Waitframes(6);
				
				//Find the edges
				for ( int a = 0; a < 48; ++a )
				{
					unless ( rightmost->isValid() ) 
					{
						rightmost = swarm[a];
						break;
					}
				}
				for ( int b = 0; b < 48; ++b )
				{
					unless ( leftmost->isValid() ) 
					{
						leftmost = swarm[b];
						break;
					}
				}
				for ( int c = 0; c < 48; ++c )
				{
					unless ( lowest->isValid() ) 
					{
						lowest = swarm[c];
						break;
					}
				}
				
				for ( int d = 0; d < 48; ++d )
				{
					if ( swarm[d]->isValid() && swarm[d]->X > rightmost->X && !swarm[d]->Misc[ISUFO]) 
					{
						rightmost = swarm[d];
					}
					if ( swarm[d]->isValid() && swarm[d]->X < leftmost->X && !swarm[d]->Misc[ISUFO])
					{
						leftmost = swarm[d];
					}
					if ( swarm[d]->isValid() && swarm[d]->Y > lowest->Y && !swarm[d]->Misc[ISUFO])
					{
						lowest = swarm[d];
					}
				}
				
				while(1)
				{
					if(--ufoclk <= 0)
					{
						bool doit = true;
						for ( int q = Screen->NumNPCs(); q > 0; --q )
						{
							npc test = Screen->LoadNPC(q);
							if ( test->Misc[ISUFO] ) 
							{
								doit = false;
							}
						}
						if ( doit ) 
						{
							npc u = Screen->CreateNPC(UFO);
							u->X = 256; u->Y = 0;
							u->Misc[ISUFO] = 1;
						}
					}
					
					
					{
						
						const int YDEPTH = 12;
						//get bunker Ys
						if ( lowest->isValid() )
						{
							if ( (lowest->Y+YDEPTH) >= shields::one::minY )
							{
								int impact = (lowest->Y) - shields::one::minY - 2; //Abs(118-(this->Y))+DESTROY_Y_OFFSET; //the depth of the impact
											
								//Erase a vertical block on every bunker the sie of this alien.
								for ( int q = 0; q < 4; ++q )
								{
									invaders::shields::bnkr[q]->Rectangle(1, 0, impact, 48, impact+7, 0, -1, 0,0,0,true,128);
								}
								
							}
						}
					}
					
					
					unless(numInvaders())
					{
						while(Screen->NumNPCs() > 1 ) Waitframe(); //1 is always present
						nextstage();
						continue;
					}
					
					findedges(swarm);
					move(leader, swarm, invclk);
					animate(swarm);
					
					//Check for Landing
					if ( lowest->isValid() && lowest->Y >= 152 && !lowest->Misc[ISUFO])
					{
						gameover = 1;
					}
					
					++invclk;
					Waitframe();
				}
				
			}
			void findedges(npc swarm)
			{
				//Find the edges
				for ( int q = 0; q < 48; ++q )
				{
					if ( rightmost->isValid() && !rightmost->Misc[ISUFO] ) break;
					rightmost = swarm[q];
				}
				for ( int q = 0; q < 48; ++q )
				{
					if ( leftmost->isValid() && !leftmost->Misc[ISUFO] ) break;
					leftmost = swarm[q];
				}
				for ( int q = 0; q < 48; ++q )
				{
					if ( lowest->isValid() && !lowest->Misc[ISUFO] ) break;
					lowest = swarm[q];
				}
				for ( int q = 0; q < 48; ++q )
				{
					unless ( swarm[q]->isValid() ) continue;
					if ( swarm[q]->Misc[ISUFO] ) continue;
					if ( swarm[q]->X > rightmost->X ) 
					{
						rightmost = swarm[q];
					}
					if ( swarm[q]->X < leftmost->X )
					{
						leftmost = swarm[q];
					}
					if ( swarm[q]->Y > lowest->X )
					{
						lowest = swarm[q];
					}
				}
			}
			void spawn(npc swarm)
			{
				wipegrid(); //Clear old pointers. 
				int id = FIRST; int x = STARTX, y = STARTY;
				starttile tiles[4] = { stA, stB, stC, stD };
				for ( int q = 0; q < NUMINVADERS; ++q )
				{
					//printf("spawning invader nuber: %d\n", q);
					if ( (q) && (!(q%12)) ) //start of a row
					{
						++id;
						y += 16;
						x = STARTX;
					}
					
					swarm[q] = Screen->CreateNPC(id);
					swarm[q]->ScriptTile = swarm[q]->OriginalTile;
					swarm[q]->X = x; swarm[q]->Y = y; //Position on the grid.
					swarm[q]->DrawYOffset = -8;
					swarm[q]->HitYOffset = -8; //So that they 'land' at the visible 8th pixel.
					x += 16; //Increment column.
					grid[q] = swarm[q]; //Store its pointer into the grid. 
					//if (DEBUG) printf("swarm[%d] x: %d\n", q, swarm[q]->X);
					//if (DEBUG) printf("swarm[%d] y: %d\n", q, swarm[q]->Y);
				}
				for ( int q = 0; q < 48; ++q )
				{
					//if (DEBUG) printf("swarm[%d] x: %d\n", q, swarm[q]->X);
					//if (DEBUG) printf("swarm[%d] y: %d\n", q, swarm[q]->Y);
				}
				
			}
			
			void animate(npc swarm)
			{
				for ( int q = 0; q < NUMINVADERS; ++q )
				{
					if ( swarm[q]->isValid() && !swarm[q]->Misc[ISUFO] )
					{
						++swarm[q]->Misc[aclk]; 
						unless (( swarm[q]->Misc[aclk]%16 ))
						{
							if ( swarm[q]->Misc[curtile] < 7 )
							{
								++swarm[q]->ScriptTile;
								++swarm[q]->Misc[curtile];
							}
							else
							{
								swarm[q]->ScriptTile = swarm[q]->OriginalTile;
								swarm[q]->Misc[curtile] = 0;
							}
						}
					}
					
				}
				
			}
			
			int numInvaders()
			{
				int ret;
				for ( int q = Screen->NumNPCs(); q > 0; --q )
				{
					npc n = Screen->LoadNPC(q);
					if ( n->ID >= FIRST && n->ID <= FIRST+3 ) ++ret;
				}
				return ret;
			}
			
			
			void splat(npc swarm)
			{
				for ( int q = 0; q < NUMINVADERS; ++q )
				{
					if ( swarm[q]->isValid() && !swarm[q]->Misc[ISUFO] )
					{
						if ( swarm[q]->HP < 1 )
						{
							unless(swarm[q]->Misc[SPLATTED])
							{
								lweapon splat = Screen->CreateLWeapon(LW_SPARKLE);
								splat->HitYOffset = -32768; 
								splat->HitYOffset = -37768;
								splat->UseSprite(SPLATSPRITE);
								
								splat->X = swarm[q]->X;
								splat->Y = swarm[q]->Y;
								Game->Counter[CR_SCORE_P1] += swarm[q]->Y;
								swarm[q]->Misc[SPLATTED] = 1;
							}
						}
					}
				}
			}
			
			int stepclk = 20;
			
			void move(npc leader, npc swarm, int clk)
			{
				unless ( clk%60 )
				{
					Audio->PlaySound(STEPSFX);
					//if (DEBUG) printf("stepclk is: %d\n", stepclk);
				}
				
				unless ( clk%(Max(stepclk<<0,1)) )
				{
					switch(leader->Dir)
					{
						case DIR_LEFT:
						{
							//if on a screen edge
							if ( leftmost->X <= 1 ) 
							{
								descend(swarm);
								leader->Dir = DIR_RIGHT;
							}
							else
							{
								//Find the maximum step
								int maxstep = ( (leftmost->X - curstep) > -1 ) ? curstep : leftmost->X;
								//Move the full step up to the edge of the screen, but not beyond
								for ( int q = 0; q < NUMINVADERS; ++q )
								{
									unless(swarm[q]->isValid()) { continue; }
									if ( swarm[q]->Misc[ISUFO] ) continue;
									swarm[q]->X -= maxstep;
								}
							}
							break;
						}
						case DIR_RIGHT:
						{
							//if on a screen edge
							if ( rightmost->X >= 239 ) 
							{
								descend(swarm);
								leader->Dir = DIR_LEFT;
							}
							else
							{
								//Find the maximum step
								int maxstep = ( (rightmost->X + curstep) < 241 ) ? curstep : (240-rightmost->X);
								//Move the full step up to the edge of the screen, but not beyond
								for ( int q = 0; q < NUMINVADERS; ++q )
								{
									unless(swarm[q]->isValid()) { continue; }
									if ( swarm[q]->Misc[ISUFO] ) continue;
									swarm[q]->X += maxstep;
								}
							}
							break;
						}
						
					}
					
				}
			}
			
			void descend(npc swarm)
			{
				for ( int q = 0; q < NUMINVADERS; ++q )
				{
					if ( swarm[q]->isValid() && !swarm[q]->Misc[ISUFO] )
					{
						swarm[q]->Y += DESCEND_Y_PIXELS;
					}
				}
				Waitframes(20); //grace
			}
			const int FIRING = 7; //Misc index to mark that an npc is firing. 
			void attack(npc swarm)
			{
				//count remaining aliens
				int count = 0; int truecount = 0;
				npc canfire[NUMINVADERS]; int cf_ix = 0;
				for ( int q = 0; q < NUMINVADERS; ++q )
				{
					if ( swarm[q]->isValid() && !swarm[q]->Misc[ISUFO] )
					{
						++count;
						//++truecount;
						canfire[cf_ix] = swarm[q];
						++cf_ix; //Put all aliens that can fire into a sequential list.
					}
				}
				
				unless(count) { return; } //no aliens left
				//choose up to six aliens to fire shots
				count = Clamp(count, 1, 6); //vound the max shots
				count = Rand(count)+1; //choose a random number of shots, min 1
				
				//Get length of truecount array
				for ( truecount = 0; canfire[truecount]->isValid(); ++truecount );
				//Select 'count' random invaders to fire.
				int firelist[48];
				memset(firelist, -1, 48);
				
				if (DEBUG) 
				{
					for ( int f = 0; canfire[f]->isValid(); ++f )
					{
						//printf("canfire[f] UID is: %d\n", canfire[f]->UID);
					}
				}
				
				/* would be nice if we allowed variable arrays locally
				npc positions[truecount];
				if ( swarm[q] ->isValid() && swarm[q]->HP > 0 )
				{
					++count;
					++truecount;
				}
				*/
			}
			void cleanup(npc swarm)
			{
				//cleanup of status values
				for ( int q = 0; q < NUMINVADERS; ++q )
				{
					if ( swarm[q]->isValid() )
					{
						//clear attacking status
						swarm[q]->Misc[FIRING] = 0;
					}
				}
			}
		} // end script 
	} // end namespace
	
	namespace playr
	{
		//int cooldown = 0;
		// Player movement and firing.
		const int POINTS_PER_LIFEFILL = 2000;
		const int HP_PER_LIFE_FILL = 8;
		const int SFX_LIFEFILL = 7;
		void lifefill(int ptr)
		{
			if ( Game->Counter[CR_SCORE_P1] > 0 )
			{
				if ( Game->Counter[CR_SCORE_P1] > ptr[inv.lfPrevious] )
				{
					if ( (Game->Counter[CR_SCORE_P1] - ptr[inv.lfPrevious]) >= POINTS_PER_LIFEFILL )
					{
						int temp = Game->Counter[CR_SCORE_P1]/1000; 
						temp = temp << 0;
						temp = temp * 1000;
						ptr[inv.lfPrevious] = temp; //crop to even thousands
						Audio->PlaySound(SFX_LIFEFILL);
						Game->DCounter[CR_LIFE] += HP_PER_LIFE_FILL;
						
					}
				}
			}
		}
		namespace missile
		{
			int clk, step, cool, x, y;
			const int SPRITE = 63;
			int STEP = 5 - ((difficulty/2)<<0); //pixels per frame
			const int TYPE = LW_SCRIPT1;
			const int XOFS = 0; 
			const int YOFS = -16;
			//missile bounding box. 
			const int HEIGHT = 12;
			const int WIDTH = 4;
			const int HITXOFS = 6;
			const int HITYOFS = 0;
			
			const int SHOT_ERODE_RADIUS = 6;
			
			lweapon script player_missile
			{
				void run()
				{
					this->HitWidth = WIDTH;
					this->HitHeight = HEIGHT;
					this->HitXOffset = HITXOFS;
					this->HitYOffset = HITYOFS;
					while(1)
					{
						//for every pixel of movement, check collisions.
						for ( int q = 0; q < STEP; ++q )
						{
							--this->Y;
							unless(SKIPBUNKERS)
							{
								bitmap scrn = Game->LoadBitmapID(RT_SCREEN);
								int col2 = scrn->GetPixel(this->X+8, this->Y+2) * 10000; //penetrates one pixel
								const int COL_FIRST = (16*11)+1;
								const int COL_LAST = (16*12)+1;
								if ( col2 >= (COL_FIRST) && col2 < (COL_LAST) ) //cset 11
								{
									bool skip;
									if ( this->X+8 <= shields::four::minX )
									{
										//must be shield 1, 2, or 3
										if ( this->X+8 <= shields::three::minX )
										{
											//must be shield 1, 2
											if ( this->X+8 <= shields::two::minX )
											{
												int hitpos = (this->X+8) - shields::one::minX;
												int impact = (this->Y) - shields::one::minY + 2; //Abs(118-(this->Y))+DESTROY_Y_OFFSET; //the depth of the impact
												//edge is the left edge of the bitmap for ffc[1]
												invaders::shields::bnkr[0]->Circle(1, hitpos, impact, SHOT_ERODE_RADIUS, 0, 1, 0,0,0, true, 128);
												this->DeadState = WDS_DEAD;
												Quit();
											}
											else
											{
												
												int hitpos = (this->X+8) - shields::two::minX;
												int impact = Abs(118-(this->Y))+8; //the depth of the impact
												invaders::shields::bnkr[1]->Circle(1, hitpos, impact, SHOT_ERODE_RADIUS, 0, 1, 0,0,0, true, 128);
												this->DeadState = WDS_DEAD;
												Quit();
											}
											
										}
										else
										{
											int hitpos = (this->X+8) - shields::three::minX;
											int impact = Abs(118-(this->Y))+8; //the depth of the impact
											
											invaders::shields::bnkr[2]->Circle(1, hitpos, impact, SHOT_ERODE_RADIUS, 0, 1, 0,0,0, true, 128);
											this->DeadState = WDS_DEAD;
									
											Quit();
											
										}
										
									}
									else
									{
										int hitpos = (this->X+8) - shields::four::minX;
										int impact = Abs(118-(this->Y))+8; //the depth of the impact
										
										invaders::shields::bnkr[3]->Circle(1, hitpos, impact, SHOT_ERODE_RADIUS, 0, 1, 0,0,0, true, 128);
										this->DeadState = WDS_DEAD;
								
										Quit();
											
										
									}
								}
							}
							//if there is a collision, move until reaching that Y pos, then kill the missile.
							for ( int q = Screen->NumNPCs(); q < 0; --q )
							{
								npc n = Screen->LoadNPC(q);
								if ( Collision(this,n) ) break;
							}
							//otherwise complete full move. 
						}
						
						Waitdraw();
						Waitframe();
					}
				}
			}
			
		}
		void clamp()
		{
			//enum bounds { UPPER, LOWER, LEFT, RIGHT, LAST };
			Player->X = Clamp(Player->X, 0, 238);
			Player->Y = 152;
			Player->Dir = DIR_UP;
		}
		const int MISSILESPR = 11;
		const int ATKSFX = 2;
		void attack()
		{
			if ( Link->PressA ) 
			{
				if ( Screen->NumLWeapons() ) 
				{
					return;
				}
				lweapon m = Screen->CreateLWeapon(missile::TYPE);
				m->Dir = DIR_UP;
				m->X = Player->X + missile::XOFS;
				m->Y = Player->Y + missile::YOFS;
				m->Step = 0; //Moves by weapon script. 
				m->Script = Game->GetLWeaponScript("player_missile");
				m->UseSprite(MISSILESPR);
				m->Power = 1;
				Audio->PlaySound(ATKSFX);
			}
		}
		const int FIRST = 78060;
		const int aclk = 2;
		const int curtile = 3;

		void init()
		{
			Game->Counter[CR_SCORE_P1] = 0;
			Game->Counter[CR_ROUND] = 1;
			Game->DisableActiveSubscreen = true;
			Player->ScriptTile = 78060;
		}
		
		player script initial
		{
			void run()
			{
				init();
			}
		}
		
		void animate()
		{
			++Player->Misc[aclk]; 
				unless (( Player->Misc[aclk]%16 ))
				{
					if ( Player->Misc[curtile] < 7 )
					{
						++Player->ScriptTile;
						++Player->Misc[curtile];
					}
					else
					{
						Player->ScriptTile = FIRST;
						Player->Misc[curtile] = 0;
					}
				}
				
		}
					
		
		
	}
	
	
	//////////////////////////////
	//        Credits.zh        //
	//           V1.00          //
	//          Venrob          //
	//////////////////////////////

	

	namespace crawl //start
	{
		typedef const int DEFINE;
		typedef const int CONFIG;
		untyped data[CD_SZ];
		enum
		{
			DATA_BITMAP,
			DATA_CURRY,
			DATA_SPACING,
			DATA_HEADER_SPACING,
			DATA_SIDE_BUFFER,
			DATA_FONT,
			DATA_TEXT_COLOR,
			CD_SZ
		};
		CONFIG DEFAULT_HEIGHT = 1024;
		CONFIG BACKGROUND_COLOR = 0x0F;
		CONFIG DEFAULT_TEXT_COLOR = 0x01;
		CONFIG DEFAULT_SIDE_BUFFER = 16;
		CONFIG DEFAULT_SPACING = 2;
		CONFIG DEFAULT_HEADER_SPACING = 8;
		CONFIG DEFAULT_FONT = FONT_ALLEGRO;
		CONFIG EXP_Y_AMNT = 256;
		//start Header System functions
		void init()
		{
			if((<bitmap>data[DATA_BITMAP])->isValid())
				bitmaps::release(<bitmap>data[DATA_BITMAP], 7);
			data[DATA_BITMAP] = bitmaps::acquire(256, DEFAULT_HEIGHT);
			(<bitmap>data[DATA_BITMAP])->Clear(0);
			data[DATA_CURRY] = 0;
			data[DATA_SPACING] = DEFAULT_SPACING;
			data[DATA_HEADER_SPACING] = DEFAULT_HEADER_SPACING;
			data[DATA_SIDE_BUFFER] = DEFAULT_SIDE_BUFFER;
			data[DATA_FONT] = DEFAULT_FONT;
			data[DATA_TEXT_COLOR] = DEFAULT_TEXT_COLOR;
		}
		void destroy() //Call when you are done rolling the credits, to delete them
		{
			if((<bitmap>data[DATA_BITMAP])->isValid())
				bitmaps::release(<bitmap>data[DATA_BITMAP], 7);
			data[DATA_BITMAP] = NULL;
			data[DATA_CURRY] = 0;
			data[DATA_SPACING] = DEFAULT_SPACING;
			data[DATA_HEADER_SPACING] = DEFAULT_HEADER_SPACING;
			data[DATA_SIDE_BUFFER] = DEFAULT_SIDE_BUFFER;
			data[DATA_FONT] = DEFAULT_FONT;
			data[DATA_TEXT_COLOR] = DEFAULT_TEXT_COLOR;
		}
		bitmap getBitmap() //The bitmap can change whenever you add a line; make sure to call this function again if you need it again!
		{
			return data[DATA_BITMAP];
		}
		void resize(int height)
		{
			if((<bitmap>data[DATA_BITMAP])->Height == height) return;
			bitmap tmp = bitmaps::acquire(256, height);
			tmp->Clear(0);
			int h = Min((<bitmap>data[DATA_BITMAP])->Height, height);
			(<bitmap>data[DATA_BITMAP])->Blit(0, tmp, 0, 0, 256, h, 0, 0, 256, h, 0, 0, 0, BITDX_NORMAL, 0, false);
			bitmaps::release(<bitmap>data[DATA_BITMAP], 7);
			data[DATA_BITMAP] = tmp;
		}
		void setSpacing(int spc)
		{
			data[DATA_SPACING] = spc;
		}
		void setHeaderSpacing(int spc)
		{
			data[DATA_HEADER_SPACING] = spc;
		}
		void setSideBuffer(int spc)
		{
			data[DATA_SIDE_BUFFER] = spc;
		}
		void setFont(int font)
		{
			data[DATA_FONT] = font;
		}
		void setTextColor(int color)
		{
			data[DATA_TEXT_COLOR] = color;
		}
		void output(char32 filepath)
		{
			bitmap tmp = bitmaps::acquire(256, data[DATA_CURRY]);
			(<bitmap>data[DATA_BITMAP])->Blit(7, tmp, 0, 0, 256, data[DATA_CURRY], 0, 0, 256, data[DATA_CURRY], 0, 0, 0, BITDX_NORMAL, 0, false);
			tmp->Write(7, filepath, true);
			bitmaps::release(tmp, 7);
		}
		//end
		//start Credits drawing functions
		void addSpace(int px)
		{
			data[DATA_CURRY] += px;
			if(data[DATA_CURRY] > (<bitmap>data[DATA_BITMAP])->Height)
			{
				resize((<bitmap>data[DATA_BITMAP])->Height + EXP_Y_AMNT);
			}
		}
		void addLine(char32 text)
		{
			addLine(text, data[DATA_FONT], TF_CENTERED, data[DATA_TEXT_COLOR], data[DATA_SPACING]);
		}
		void addLine(char32 text, int font)
		{
			addLine(text, font, TF_CENTERED, data[DATA_TEXT_COLOR], data[DATA_SPACING]);
		}
		void addLine(char32 text, int font, int format)
		{
			addLine(text, font, format, data[DATA_TEXT_COLOR], data[DATA_SPACING]);
		}
		void addLine(char32 text, int font, int format, int font_color)
		{
			addLine(text, font, format, font_color, data[DATA_SPACING]);
		}
		void addHeader(char32 text)
		{
			addLine(text, data[DATA_FONT], TF_CENTERED, data[DATA_TEXT_COLOR], data[DATA_HEADER_SPACING]);
		}
		void addHeader(char32 text, int font)
		{
			addLine(text, font, TF_CENTERED, data[DATA_TEXT_COLOR], data[DATA_HEADER_SPACING]);
		}
		void addHeader(char32 text, int font, int format)
		{
			addLine(text, font, format, data[DATA_TEXT_COLOR], data[DATA_HEADER_SPACING]);
		}
		void addHeader(char32 text, int font, int format, int font_color)
		{
			addLine(text, font, format, font_color, data[DATA_HEADER_SPACING]);
		}
		void addLine(char32 text, int font, int format, int font_color, int spc)
		{
			int x;
			switch(format)
			{
				case TF_NORMAL:
					x = data[DATA_SIDE_BUFFER];
					break;
				case TF_RIGHT:
					x = 256 - data[DATA_SIDE_BUFFER];
					break;
				case TF_CENTERED:
				default: //In case you pass a bad format?
					x = 256/2;
			}
			int fontheight = Text->FontHeight(font);
			bitmap b = data[DATA_BITMAP];
			if(data[DATA_CURRY] + spc + fontheight > b->Height)
			{
				resize(b->Height + EXP_Y_AMNT);
				b = data[DATA_BITMAP];
			}
			b->DrawString(0, x, data[DATA_CURRY] + spc, font, font_color, -1, format, text, OP_OPAQUE);
			data[DATA_CURRY] += spc + fontheight;
		}
		void addScreenLine(char32 text, int font, int format, int font_color, int y)
		{
			int x;
			int spc = data[DATA_HEADER_SPACING];
			switch(format)
			{
				case TF_NORMAL:
					x = data[DATA_SIDE_BUFFER];
					break;
				case TF_RIGHT:
					x = 256 - data[DATA_SIDE_BUFFER];
					break;
				case TF_CENTERED:
				default: //In case you pass a bad format?
					x = 256/2;
			}
			int fontheight = Text->FontHeight(font);
			Screen->DrawString(0, x, y, font, font_color, -1, format, text, OP_OPAQUE);
			data[DATA_CURRY] += spc + fontheight;
		}
		//end
		//start Screen drawing functions
		void drawCredits(int y)
		{
			Screen->Rectangle(7, 0, -56, 255, 175, BACKGROUND_COLOR, 1, 0, 0, 0, true, OP_OPAQUE);
			DEFINE HEI = 224 + (y < 0 ? y : 0);
			if(HEI <= 0) return;
			int desty = (y < 0 ? -y : 0) -56;
			if(y < 0) y = 0;
			(<bitmap>data[DATA_BITMAP])->Blit(7, RT_SCREEN, 0, y, 256, HEI, 0, desty, 256, HEI, 0, 0, 0, BITDX_NORMAL, 0, true);
		}
		
		void rollCredits(int scrollspeed)
		{
			for(int y = -224; y < data[DATA_CURRY]; y += scrollspeed)
			{
				drawCredits(y);
				for(int q = 0; q < CB_MAX; ++q) //Kill all inputs
				{
					Input->Button[q] = false;
					Input->Press[q] = false;
				}
				Waitframe();
			}
		}
		
		void blackDelay(int frames)
		{
			while(frames-- > 0)
			{
				Screen->Rectangle(7, 0, -56, 255, 175, BACKGROUND_COLOR, 1, 0, 0, 0, true, OP_OPAQUE);
				Waitframe();
			}
		}
		//end
	} //end

	const int DELAY_SECS = 4; //delay before starting game
	global script intro //start
	{
		void run()
		{
			Audio->PlaySound(SFX_INTRO);
			crawl::init();
			crawl::addHeader("It is the year 5780...", FONT_SCIFI, TF_CENTERED, aliens::COLOR(aliens::CSET(6),14));
			crawl::addLine("...the spring time in the month of Nisan", FONT_SINQL);
			crawl::addHeader(" ");
			crawl::addLine("The PAGANS are INVADING!!", FONT_PET, TF_CENTERED, aliens::COLOR(aliens::CSET(7),17));
			crawl::addHeader(" ");
			crawl::addLine("You must RESCUE HUMANITY from their", FONT_PET);
			crawl::addLine("IDOLATRY, and their misguided beliefs!", FONT_PET);
			crawl::blackDelay(30);
			crawl::rollCredits(.5);
			crawl::blackDelay(30);
			crawl::destroy();
			Waitframes(DELAY_SECS*60);
			Audio->EndSound(SFX_INTRO);
			int selection = 0;
			int selected = 0;
			until(selected)
			{
				//Draw the difficulty menu.
				//Screen->DrawString(7, 0, 120, , , -1,  TF_CENTERED, "NORMAL", 128);
				crawl::addScreenLine("SELECT SKILL", FONT_GAIA, TF_CENTERED, 1, 40);
				crawl::addScreenLine("NORMAL", FONT_SCIFI, TF_CENTERED, (selection == 0 ) ? aliens::COLOR(aliens::CSET(7),17) : aliens::COLOR(aliens::CSET(6),14), 60);
				crawl::addScreenLine("EXPERT", FONT_SCIFI, TF_CENTERED, (selection == 1 ) ? aliens::COLOR(aliens::CSET(7),17) : aliens::COLOR(aliens::CSET(6),14), 70);
				crawl::addScreenLine("MASOCHIST", FONT_SCIFI, TF_CENTERED, (selection == 2 ) ? aliens::COLOR(aliens::CSET(7),17) : aliens::COLOR(aliens::CSET(6),14), 80);
				
				if ( Player->PressUp )
				{
					switch(selection)
					{
						case 0: selection = 2; break;
						case 1: selection = 0; break;
						case 2: selection = 1; break;
					}
					Audio->PlaySound(3);
				}
				if ( Player->PressDown )
				{
					switch(selection)
					{
						case 0: selection = 1; break;
						case 1: selection = 2; break;
						case 2: selection = 0; break;
					}
					Audio->PlaySound(3);
				}
				
				if ( Player->PressStart || Player->PressA || Player->PressB )
				{
					switch(selection)
					{
						case 0: Audio->PlaySound(2); break;
						case 1: Audio->PlaySound(8); break;
						case 2: Audio->PlaySound(5); break;
					}
					difficulty = selection+1;
					selected = 1;
				}
				/*(int layer, 
			int x, int y, 
			int font, int color, int background_color, int format, 
			"string", 
			int opacity );*/
				
				Waitframe();
				
			}
		}
	} //end
	
}