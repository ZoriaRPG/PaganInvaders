// Invaders
// v0.08
// 30th March, 2020
// ZoriaRPG
//
/*
* Change History
* 0.0.1 - Project Begins
* 0.0.2 - Fixed initial compile. 
* 0.0.3 - Added playr::missile, and initial lweapon script. 
* 0.0.4 - Aliens now move, spawn and aniate properly. Player is clamped properly. 
* 	- Player is now animated. Shields are drawn using bitmaps. 
* 	- Known Bugs: Shields are not obliterated by aliens because of logic issues. 
* 0.0.4 - Added player attack. Disabled bunker bitmap/getpixel checks for now. 
* 	- Added sounds and actions. Added player init script. 
* 	- Fixed bugs with enemies not attacking. 
* 0.05  - Game now ends on landing. Enemy missiles now damage the player. 
* 0.06	- Fixed some visual bugs, and added splat effect. 
* 0.07  - Added scoring. Disabled the active subscreen.
* 	- Added additional stages. Show 'R' (round) indicator. 
* 0.08  - Some clamping to force step to stay in bounds. 
*/

int ofs = 0;
namespace invaders
{
	int alienclk; //one second clock
	int hasturned = 0;
	int gameover = 0;
	const int SPLATSPRITE = 34; 
	namespace shields
	{
		bitmap bnkr[4];
		ffc loc[4] = { NULL, NULL, NULL, NULL };
		const int TILE = 78213;
		const int CSET = 11;
		void init()
		{
			for ( int q = 0; q < 4; ++q )
			{
				loc[q] = NULL;
				bnkr[q] = Game->CreateBitmap(3*16, 2*16);
				printf("bnkr[q]: %d\n", <int>bnkr[q]);
				bnkr[q]->DrawTile(0, 0, 0, TILE, 3, 2, CSET, -1, -1, 0, 0, 0, 0, true, 128);
			}
			
		}
		void draw(ffc f, int spin)
		{
			//printf("bnkr[f->InitD[0]] is: %d\n", <int>bnkr[f->InitD[0]]);
			//bnkr[f->InitD[0]]->Blit(0, RT_SCREEN, 0, 0, 3*16, 2*16, f->X, f->Y, 3*16, 2*16, 0, 0, 0, 0, 0, true);
			//!Revert to this to stop the spin. 
			//bnkr[f->InitD[0]]->Blit(0, <bitmap>(-2), 0, 0, 3*16, 2*16, f->X, f->Y, 3*16, 2*16, 0-(ofs/30), 0, 0, 0, 0, true);
			bnkr[f->InitD[0]]->Blit(0, <bitmap>(-2), 0, 0, 3*16, 2*16, f->X, f->Y, 3*16, 2*16, 0-(ofs/30), 0, 0, 0, 0, true);
			if ( spin ) --ofs;
		}
		ffc script bunker
		{
			void run(int id)
			{
				// Probably doesn't need a script. Changers would work.
				// Oh, but we need to draw it from a bitmap. Flidd. 
				loc[id] = this;
				while(1)
				{
					draw(this, (this->InitD[1]));
					Waitframe();
				}
			}
		}
		
	}
	
	void runclock()
	{
		++alienclk;
		if ( alienclk > 59 ) alienclk = 0;
	}
	void nextstage()
	{
		//Audio->PlaySound(5);
		++Game->Counter[CR_KEYS];
		aliens::spawn();
	}
	global script inv
	{
		void run()
		{
			playr::init();
			shields::init(); //Set up bunker bitmaps.
			aliens::init(); //Set up temp bitmap for shield collisions. 
			aliens::spawn();
			while(1)
			{
				if ( gameover ) 
				{
					GameOver();
				}
				runclock();
				aliens::animate();
				playr::animate();
				playr::clamp();
				playr::attack();
				
				if ( aliens::hitedge )
				{
					printf("hit screen edge\n");
					for ( int qe = Screen->NumNPCs(); qe > 0; --qe )
					{
						npc nn = Screen->LoadNPC(qe);
						
						switch(nn->Dir)
						{
							case DIR_LEFT:
							{
								//++nn->X;
								nn->Dir = DIR_RIGHT;
								aliens::descend(nn);
								break;
							}
							case DIR_RIGHT:
							{
								//--nn->X;
								nn->Dir = DIR_LEFT;
								aliens::descend(nn);
								break;
							}
						}
					}
					aliens::hitedge = 0;
				}
				unless(Screen->NumNPCs())
				{
					nextstage();
				}
				Waitdraw();
				playr::clamp();
				Waitframe();
			}
		}
	}
	
	global script newgame
	{
		void run()
		{
			playr::init();
			shields::init(); //Set up bunker bitmaps.
			aliens::init(); //Set up temp bitmap for shield collisions. 
			//aliens::animate();
			aliens::spawn();
		}
	}
	
	void GameOver()
	{
		while(1)
		{
			Screen->DrawString(7, 100, 100, 1, 0x92, 0x0F, 0, "    GAME OVER    ", 128);
			Waitframe();
		}
	}
		
	namespace aliens
	{
		npc grid[12*4]; 
		int turn_cooldown = 0; 
		int hitedge = 0;
		const int COOLDOWN_TIME = 15;
		enum adir { dLeft, dRight, dLast };
		const int DESCEND_Y_PIXELS = 16;
		const int FIRECLK = 1;
		const int FIRECLK_MIN = 100;
		const int FIRECLK_MAX = 400;
		const int FIRST = 180;
		
		bitmap tmpbmp;
		void init()
		{
			tmpbmp = Game->CreateBitmap(16,16);
		}
		
		const int STARTX = 32;
		const int STARTY = 16;
		
		enum starttile { stA = 78000, stB = 78020, stC = 78040, stD = 78000 }; //unintentional Pun. 
		
		const int INITIALSTEP = 8; //pixels per second!, not frame
		int step = INITIALSTEP; //This increases as enemies die.
		
		void wipegrid()
		{
			for ( int q = 0; q < 48; ++q ) 
			{
				grid[q] = NULL;
			}
		}
		
		//Misc[]
		const int aclk = 2; 
		const int curtile = 3;
		void animate()
		{
			for ( int q = Screen->NumNPCs(); q > 0; --q )
			{
				npc n = Screen->LoadNPC(q);
				++n->Misc[aclk]; 
				unless (( n->Misc[aclk]%16 ))
				{
					if ( n->Misc[curtile] < 7 )
					{
						++n->ScriptTile;
						++n->Misc[curtile];
					}
					else
					{
						n->ScriptTile = n->OriginalTile;
						n->Misc[curtile] = 0;
					}
				}
				
			}
			
		}
		void spawn()
		{
			step = INITIALSTEP; 
			wipegrid(); //Clear old pointers. 
			int id = FIRST; int x = STARTX, y = STARTY;
			starttile tiles[4] = { stA, stB, stC, stD };
			for ( int q = 0; q < 48; ++q )
			{
				if ( (q) && (!(q%12)) ) //start of a row
				{
					++id;
					y += 16;
					x = STARTX;
				}
				npc n = Screen->CreateNPC(id);
				n->X = x; n->Y = y; //Position on the grid.
				n->DrawYOffset = -8;
				n->HitYOffset = -8; //So that they 'land' at the visible 8th pixel.
				x += 16; //Increment column.
				grid[q] = n; //Stor its pointer into the grid. 
			}
		}
		
		adir dir = dRight; //The direction of their march.
		
		void changedir()
		{
			dir = ((dir)?dRight:dLeft);
		}
		void descend(npc n)
		{
			n->Y += DESCEND_Y_PIXELS;
		}
		
		const int MAXEW = 6;
		const int ATKSFX = 1;
		
		void runclock(npc n)
		{
			//May need to adjust the ret type here.
			if ( Screen->NumEWeapons() >= MAXEW ) return;
			//Check the individual firing clock of the alien.
			int clk = n->Misc[FIRECLK];
			printf("n->Misc[FIRECLK] clk is: %d\n", clk);
			if ( n->Misc[FIRECLK] > 0 )
			{
				--n->Misc[FIRECLK]; //Cooldown
			}
			else if (  n->Misc[FIRECLK] < 0 )
			{
				n->Misc[FIRECLK] = 0;
			}
			else
			{
				unless ( Rand(5) ) 
				{
					n->Misc[FIRECLK] = Rand(FIRECLK_MIN,FIRECLK_MAX);
					n->Attack();
					Audio->PlaySound(ATKSFX);
				}
			}
			/*
			unless(clk) 
			{
				n->Misc[FIRECLK] = Rand(FIRECLK_MIN,FIRECLK_MAX);
				unless ( Rand(5) ) 
				{
					n->Attack();
					Audio->PlaySound(ATKSFX);
					printf("attacking\n");
				}
				//! The weapon script handles the enemy missile
			}
			else
			{
				
			}
			*/
		}
		/* 
			Returns if the aliens are on the edge of the screen, based on their direction.
		*/
		
		const int MISSILESPR = 10;
		const int STEP = 2;
		eweapon script enemy_missile
		{
			void run()
			{
				this->Dir = DIR_DOWN;
				int type2 = Rand(1);
				this->UseSprite(MISSILESPR + (type2));
				this->Damage = 2;
				int step = STEP + type2;
				while(1)
				{
					//for every pixel of movement, check collisions.
					for ( int q = 0; q < STEP; ++q )
					{
						++this->Y;
						//if there is a collision, move until reaching that Y pos, then kill the missile.
						
						//otherwise complete full move. 
					}
					
					Waitdraw();
					Waitframe();
				}
			}
		}
		
		bool onedge(npc n)
		{
			switch(n->Dir)
			{
				case DIR_LEFT:
				{
					if ( n->X < 1 ) 
					{
						//Change direction
						//changedir();  //global
							//Descend
						//descend(n);
						return true;
					}
				}
				case DIR_RIGHT:
				{
					if ( n->X > 239 ) 
					{
						//Change direction
						//changedir();  //global
						//Descend
						//descend(n);
						return true;
					}
				}
				default: return false;
			}
			return false;
		}
		
		const int STEPSFX = 3;
		int maxstep;
		npc script alien
		{
			void run()
			{
				this->ScriptTile = this->OriginalTile;
				this->Dir = DIR_RIGHT;
				int tmpx, tmpy;
				int splatted = 0;
				//int aclk; //8 frames, at a speed of 16
				//int curtile = 0;
				while(1)
				{
					if ( this->HP <= 0 ) 
					{
						
						unless(splatted)
						{
							lweapon splat = Screen->CreateLWeapon(LW_SPARKLE);
							splat->HitYOffset = -32768; 
							splat->HitYOffset = -37768;
							splat->UseSprite(SPLATSPRITE);
							
							splat->X = this->X;
							splat->Y = this->Y;
							this->DrawYOffset = -32768;
							switch(Screen->NumNPCs())
							{
								case 24...49: aliens::step = 8; break;
								case 19...23: aliens::step = 16; break;
								case 1...8: aliens::step = 32; break;
								default: break;
							}
							bool a = onedge(this);
							printf("aliens::step: %d\n", aliens::step);
							Game->Counter[CR_RUPEES] += this->Y;
							splatted = 1;
						}
						
						Quit();
					}
					//Animation always happens, but not here.
					/*++aclk; 
					unless (( aclk%16 ))
					{
						if ( curtile < 8 )
						{
							++this->ScriptTile;
							++curtile;
						}
						else
						{
							this->ScriptTile = this->OriginalTile;
							curtile = 0;
						}
					}*/
					
					//Alien actions happen in SECONDS, not in FRAMES.
					while(alienclk < 59) 
					{
						if ( this->HP <= 0 ) 
						{
							unless(splatted)
							{
								lweapon splat = Screen->CreateLWeapon(LW_SPARKLE);
								splat->HitYOffset = -32768; 
								splat->HitYOffset = -37768;
								splat->UseSprite(SPLATSPRITE);
								
								splat->X = this->X;
								splat->Y = this->Y;
								this->DrawYOffset = -32768;
								switch(Screen->NumNPCs())
								{
									case 24...49: aliens::step = 8; break;
									case 19...23: aliens::step = 16; break;
									case 1...8: aliens::step = 32; break;
									default: break;
								}
								//aliens::step += 0.50;
								bool a = onedge(this);
								printf("aliens::step: %d\n", aliens::step);
								Game->Counter[CR_RUPEES] += this->Y;
								splatted = 1;
							}
							
							Quit();
						}
						Waitframe();
					}

					tmpbmp->Clear(0);
					tmpbmp->DrawTile(0, 0, 0, this->ScriptTile, 1, 1, this->CSet, -1, -1, 0, 0, 0, -1, true, 128);
					
					
					//Every 59th frame
					
				//	//If cooldown on movement is set, wait. 
				//	while(--turn_cooldown > 0) 
				//	{
				//		//Don't continue to move for a few frames.
				//		Waitframe();
				//	}
					//Move left or right based on dir.
					for ( int q = 0; q < ((aliens::step)<<0); ++q )
					{
						//for each pixel of their step...
						tmpx = Clamp(((this->Dir == DIR_RIGHT)?(this->X+q):(this->X-q)), 0, 240);
						bool a = onedge(this);
						//Check for collisions
						
						//Check for touching the shields
						
						//Obliterate shields
					
						bitmap playfield = Game->LoadBitmapID(RT_SCREEN);
						/*
						for ( int ex = 0; ex < 16; ++ex )
						{
							for ( int ey = 0; ey < 16; ++ey )
							{
								if ( Graphics->GetPixel(playfield, this->X + ex, this->Y + ey) )
								{
									//compare against the shape of the enemy bitmap. 
									printf("overlay at %d, %d\n", ex, ey);
									
								}
							}
							
						}
						*/
						
						/*for ( int q = 0; q < 4; ++q )
						{
							if ( Collision(this, shields::loc[q]) )
							{
								printf("Shield Collision\n");
								//Find the offset to the current shield
								int shx = shields::loc[q]->X;
								int shy = shields::loc[q]->Y;
								
								int alnx = this->X;
								int alny = this->Y;
								
								int shieldbmpx = Abs(shx-alnx);
								int shieldbmpy = Abs(shy-alny);
								
								//printf here
								
								for ( int bx = 0; bx < 16; ++bx )
								{
									for ( int by = 0; by < 16; ++by )
									{
										//Solid pixels of the alien wipe out blocks of the shield.
										if ( Graphics->GetPixel(tmpbmp, bx, by) )
										{
											printf("%d,%d; ", bx, by);
											//shields::bnkr[q]->PutPixel(7, shieldbmpx, shieldbmpy, 0, 0,0,0, 128);
										}
									}
								}
							}
							
						}*/
						
					}
					
					Audio->PlaySound(STEPSFX);
					
					//Perform actual movement
					switch(this->Dir)
					{
						case DIR_LEFT:
						{
							maxstep = 0;
							for ( int q = 0; q < step; ++q )
							{
								++maxstep;
								if (( this->X-maxstep ) < 0 ) 
								{
									--maxstep;
									break;
								}
							}
							
								
							this->X = this->X-maxstep;
							
							break;
						}
						case DIR_RIGHT:
						{
							maxstep = 0;
							for ( int q = 0; q < step; ++q )
							{
								++maxstep;
								if (( this->X+maxstep ) > 240 ) 
								{
									--maxstep;
									break;
								}
							}
							
								
							this->X = this->X+maxstep;
							
							break;
						}
						
					}
					
					//check for screen edge. 
					bool edge = onedge(this);
					if ( edge ) 
					{
						aliens::hitedge = 1;
					}
					
					//If we reach the edge:
						//Move down one column.
						//Change dir. 
				
					//Set dirchange cooldown
					turn_cooldown = COOLDOWN_TIME;
					
					//Check if we have landed.
					if ( this->Y >= 152 )
					{
						gameover = 1;
					}
					
						
					//! Move one pixel at a time and check for bunkers.
					//! Wipe bunker bitmaps column on collision. 
						
					//try to fire
					runclock(this);
						
					//if we die, bump the step.
					Waitdraw();
					Waitframe();
				}
			}
		}
				
	}

	namespace playr
	{
		//int cooldown = 0;
		// Player movement and firing.
		namespace missile
		{
			int clk, step, cool, x, y;
			const int SPRITE = 63;
			const int STEP = 2; //pixels per frame
			const int TYPE = LW_ARROW;
			const int XOFS = 0; 
			const int YOFS = -16;
			//missile bounding box. 
			const int HEIGHT = 12;
			const int WIDTH = 4;
			const int HITXOFS = 6;
			const int HITYOFS = 2;
			
			lweapon script player_missile
			{
				void run()
				{
					while(1)
					{
						//for every pixel of movement, check collisions.
						for ( int q = 0; q < STEP; ++q )
						{
							--this->Y;
							//if there is a collision, move until reaching that Y pos, then kill the missile.
							for ( int q = Screen->NumNPCs(); q < 0; --q )
							{
								npc n = Screen->LoadNPC(q);
								if ( Collision(this,n) ) break;
							}
							//otherwise complete full move. 
						}
						
						Waitdraw();
						Waitframe();
					}
				}
			}
			
		}
		void clamp()
		{
			//enum bounds { UPPER, LOWER, LEFT, RIGHT, LAST };
			Player->X = Clamp(Player->X, 0, 238);
			Player->Y = 152;
			Player->Dir = DIR_UP;
		}
		const int MISSILESPR = 11;
		const int ATKSFX = 2;
		void attack()
		{
			if ( Link->PressA ) 
			{
				if ( Screen->NumLWeapons() ) 
				{
					return;
				}
				lweapon m = Screen->CreateLWeapon(missile::TYPE);
				m->Dir = DIR_UP;
				m->X = Player->X + missile::XOFS;
				m->Y = Player->Y + missile::YOFS;
				m->Step = 0; //Moves by weapon script. 
				m->Script = Game->GetLWeaponScript("player_missile");
				m->UseSprite(MISSILESPR);
				m->Power = 1;
				Audio->PlaySound(ATKSFX);
			}
		}
		const int FIRST = 78060;
		const int aclk = 2;
		const int curtile = 3;

		void init()
		{
			Game->Counter[CR_KEYS] = 1;
			Game->DisableActiveSubscreen = true;
			Player->ScriptTile = 78060;
		}
		
		player script initial
		{
			void run()
			{
				init();
			}
		}
		
		void animate()
		{
			++Player->Misc[aclk]; 
				unless (( Player->Misc[aclk]%16 ))
				{
					if ( Player->Misc[curtile] < 7 )
					{
						++Player->ScriptTile;
						++Player->Misc[curtile];
					}
					else
					{
						Player->ScriptTile = FIRST;
						Player->Misc[curtile] = 0;
					}
				}
				
		}
					
		
		
	}
	namespace shields
	{
		
		
	}
}